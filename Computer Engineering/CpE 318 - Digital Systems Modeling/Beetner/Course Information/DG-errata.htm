<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   <meta name="GENERATOR" content="Mozilla/4.7 [en] (WinNT; I) [Netscape]">
<!-- HTML generated by Cyberleaf(tm) 1.0.0 -->
</head>
<body>

<h2>
The Designer's Guide to VHDL</h2>
Peter J. Ashenden
<p>
<hr>
<h1>
Errata</h1>
If you detect an error, I would be pleased to hear about it. You can send
email to me at <a href="mailto:peter.ashenden@computer.org">peter.ashenden@computer.org</a>.
I will add errata to this list and acknowledge you as the finder. However,
before sending an erratum, please check to make sure it's not already on
the list.
<p>Thanks.
<ul>
<li>
<a href="#errata-1">Errata for the first to fourth printings (corrected
in fifth printing)</a></li>

<li>
<a href="#errata-5">Errata remaining in the fifth and subsequent printings</a></li>
</ul>

<hr>
<h2>
<a NAME="errata-1"></a>Errata for the first to fourth printings (corrected
in fifth printing)</h2>
You can tell which printing of the book you have by looking at the copyright
page overleaf from the title page.&nbsp; Below the line "Printed in the
United States of America" is a line with one or more double-digit and single-digit
numbers.&nbsp; The rightmost double-digit number is the year of printing,
and the rightmost single-digit number is the printing number.&nbsp; For
example, the line
<blockquote>00&nbsp;&nbsp; 99&nbsp;&nbsp; 98&nbsp;&nbsp; 97&nbsp;&nbsp;
96&nbsp;&nbsp;&nbsp;&nbsp; 5&nbsp;&nbsp; 4&nbsp;&nbsp; 3&nbsp;&nbsp; 2&nbsp;&nbsp;
1</blockquote>
indicates the first printing (in 1996).
<p>
<hr WIDTH="100%">
<p>From: hutchins@west.smc.com (Robert Hutchins x2441)
<p>In Figure 1-4 on page 6, there are two blocks labeled S. The one on
the right should be labeled M.&nbsp;
<hr>
<p>From: Ben Cohen &lt;VhdlCohen@aol.com>
<p>On page 198, in the discussion of procedure parameters, the text states:
<blockquote>"It is just a quirk of VHDL that we can specify both<b> constant
</b>and
<b>in</b>,
even though to do so is redundant. Usually we simply leave out the keyword
<b>constant</b>,
relying on the mode to make our intentions clear."</blockquote>
The LRM states that a constant parameter may not be of an access type or
a file type. Thus, a parameter of an access type must be of class<b> variable
</b>.
In VHDL-87, a parameter of a file type must be of class<b> variable
</b>.
In VHDL-93, a parameter of a file type must be of class<b> file</b>. Insert
after the above quoted sentences:
<blockquote>"(The exceptions are parameters of access types, discussed
in Chapter 17, and file types, discussed in Chapter 18.)"</blockquote>

<hr>
<p>From: Peter J. Ashenden &lt;petera@cs.adelaide.edu.au>
<p>In Figure 6-10 on page 174, the labels "ovf" on the two adders should
be moved left a bit to clear the symbol outline.
<p>In Figure 7-23 on page 220, the leftmost of the two vertical lines should
be extended to meet the end of the horizontal line.&nbsp;
<hr>
<p>From: Marvin Rich &lt;mrich@VNET.IBM.COM>
<p>In Figure 7-21 on page 218, the procedure p1 contains an assignment
to the signal s. Since s and p1 are both declared in the enclosing architecture
body, the asignment to s is illegal, for the reasons discussed in the last
paragraph on page 202. In Figure 7-21, replace "s &lt;= v1;" with "v1 :=
s;".&nbsp;
<hr>
<p>From: Garland Bayley &lt;garlandb@acm.org>
<p>On page 320, second to last line, the text states, "If there is a primary
binding indication, the incremental binding indication may not include
an entity part." Replace "may not" with "must not", to emphasize that in
this circumstance an entity part is prohibited in the incremental binding
indication.&nbsp;
<hr>
<p>From: Pat Narikawa &lt;inarikawa@ccgate.hac.com>
<p>On page 38, make the following corrections.
<p>Line 17: change "There are two predefined ..." to "There are three predefined
..."
<p>Insert after line 18 a new code line:
<blockquote><b>type</b> file_open_kind<b> is</b> (read_mode, write_mode,
append_mode);</blockquote>
Line 21: change "and the type file_open_status is" to "and the types file_open_kind
and file_open_status are".
<p>Change the sentence in the VHDL-87 break-out to:
<blockquote>The types file_open_kind and file_open_status are not predefined
in VHDL-87.</blockquote>

<hr>
<p>From: Christoph Cerny &lt;cerny@fhe.tgm.ac.at>
<p>On page 217, in the VHDL-87 break-out, replace the operator<b> xor</b>
with <b>xnor</b>.
<p>On page 624, in the VHDL-87 break-out, replace the operator<b> xor</b>
with <b>xnor</b>.
<p>On page 688, in the index entry for "xnor operator", add a reference
to page 217.&nbsp;
<hr>
<p>From: Peter J. Ashenden &lt;petera@cs.adelaide.edu.au>
<p>In Figure 5-32 on page 150, the instances of the reg4 entity should
not include the and gates.&nbsp; Instead, the clr and clk inputs to each
reg4 instance should be connected as separate inputs to each flipflop,
as shown in this <a href="corrected-figure-5-32.pdf">corrected version</a>.
<br>
<hr WIDTH="100%">
<p>From: Ken DellaPenta at Morgan Kaufmann Publishers, Inc.
<p>On page 28, the cross-reference to Chapter 7 should be to Chapter 8.
<p>On page 36, the cross-reference to Section 2.3 should be to Section
2.4.
<p>Exercise 3 of Chapter 5 is not completely answered in Appendix G.&nbsp;
On page 659, add the following to the end of the answer to Exercise 3:
<ul>At time 60 ns, s'last_event is 30 ns, s'last_active is 5 ns, and s'last_value
is '0'.</ul>

<hr WIDTH="100%">
<p>From: Peter J. Ashenden &lt;petera@cs.adelaide.edu.au>
<p>On page 52, Exercise 9 should be marked as difficulty level 2, not 1.
<p>
<hr WIDTH="100%">
<p>From: Alexei Krouglov &lt;Alexei.Krouglov@matrox.com>
<p>On page 181, change the last word of the page from "subtract" to "add".
<p>
<hr WIDTH="100%">
<p>From: Edward Wade at Morgan Kaufmann Publishers, Inc.
<p>On page 136, Figure 5-24 is missing a caption.&nbsp; Insert the following
caption:
<ul>An entity declaration for a ROM, including a passive process for tracing
read operations.</ul>

<hr WIDTH="100%">
<p>From: Alexei Krouglov &lt;Alexei.Krouglov@matrox.com>
<p>On page 346, fourth to last line: change "back_array" to "bank_array".
<p>On page 359, eighth line, insert a new sentence after "... of the value.":
<ul>(The "ori" instruction is shown in Figure 15-5 on page 360.)</ul>
In Figure 15-35 on page 400, change the lower of the two labels "S1 bus"
to "S2 bus".
<p>On page 430, tenth line from the bottom, change "ir_enable" to "ir_immed2_en".
<p>
<hr WIDTH="100%">
<p>From: Graham Minchin &lt;gtminch@tartarus.uwa.edu.au>
<p>On page 43, Figure 2-4: the line from "record types" to "constrained
array types" should be from "array types" to "constrained array types."
<br>
<hr WIDTH="100%">
<h2>
<a NAME="errata-5"></a>Errata remaining in the fifth and subsequent printings</h2>
You can tell which printing of the book you have by looking at the copyright
page overleaf from the title page.&nbsp; Below the line "Printed in the
United States of America" is a line with one or more double-digit and single-digit
numbers.&nbsp; The rightmost double-digit number is the year of printing,
and the rightmost single-digit number is the printing number.&nbsp; For
example, the line
<blockquote>00&nbsp;&nbsp; 99&nbsp;&nbsp; 98&nbsp;&nbsp;&nbsp;&nbsp; 5</blockquote>
indicates the fifth printing (in 1998).
<p>
<hr WIDTH="100%">
<br>From: Neil Boroky at The University of Adelaide
<p>In Figure 5-10 on page 120: the labelling of the fourth and fifth delta
cycles should be "0 + 3 delta" and "0 + 4 delta" respectively.
<p>
<hr WIDTH="100%">
<p>From: John A. Rupf, Ph.D. &lt;jrupf@spsu.edu>
<p>On page 35: In the type definition for length, the correct number of
um per mil is 25.4.&nbsp; However, VHDL requires the multiple in a secondary
units definition to be an integer.&nbsp; Thus we cannot change 254 um to
25.4 um in this context.&nbsp; Instead, change the type declaration to
the following:
<p><tt>&nbsp;&nbsp;&nbsp; <b>type</b> length is range 0 <b>to</b> 1E9</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>units</b></tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; um;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-- primary unit: micron</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mm = 1000 um;&nbsp;&nbsp;&nbsp;&nbsp;
-- metric units</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m = 1000 mm;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inch = 25400 um;&nbsp;
-- imperial units</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; foot = 12 inch;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>end units</b> length;</tt>
<p>Also, in the examples of physical literals at the bottom of page 35,
delete "450 mil", and insert "2 foot" at the end of the line.
<p>
<hr WIDTH="100%">
<p>From: Todd Salter &lt;ra1700@email.sps.mot.com>
<p>In Exercise 11 on page 79: The problem statement requires you to develop
a model with an input of an enumeration type.&nbsp; This requires an entity
declaration with an input port of the enumeration type.&nbsp; The only
way an enumeration type can be made visible at the point of a port declaration
is to declare the enumeration type in a package.&nbsp; However, packages
are not introduced until a later chapter.
<p>To avoid this difficulty, change the problem statement as follows:
<p>Develop a model for a floating-point arithmetic unit with data inputs
x and y, data output z and function code inputs f1 and f0 of type bit.&nbsp;
Function codes f1 = '0' and f0 = '0' produce addition; f1 = '0' and f0
= '1' produce subtraction of y from x; f1 = '1' and f0 = '0' produce multiplication;
and f1 = '1' and f0 = '1' produce division of x by y.
<p>In the solution to Exercise 3 on page 658: The exit statement should
exit from all of the nested loops.&nbsp; Label the outermost loop with
the label "search_loop", and change the exit statement to refer to this
label.&nbsp; The corrected code is:
<p><tt>&nbsp;&nbsp;&nbsp; ...</tt>
<br><tt>&nbsp;&nbsp;&nbsp; search_loop : <b>for</b> side <b>in</b> 0 <b>to</b>
1 <b>loop</b></tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>for</b> track <b>in</b>
0 <b>to</b> 79 <b>loop</b></tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>for</b>
sector <b>in</b> 0 <b>to</b> 17 <b>loop</b></tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>if</b>
... <b>then</b></tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
...</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<b>exit</b> search_loop;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
...</tt>
<p>
<hr WIDTH="100%">
<p>From Konrad Schl&ouml;gl &lt;profichip.ks@gmx.net>
<p>On page 477: In the second to last line, replace "current_stimulus"
with "current_cell".
<p>
<hr WIDTH="100%">
<p>From Sue Tyerman &lt;cisspt@cs.unisa.edu.au>
<p>In Figure 6-9 on page 173: The first value in the waveform for x_real
should be "4000", not "0004".
<p>
<hr WIDTH="100%">
<p>From: Peter J. Ashenden &lt;petera@cs.adelaide.edu.au>
<p>On page 513, seventh and eighth lines: Replace the sentence "The operation
writes ... to null." with:
<blockquote>The operation writes the complete line of text to the output
file and resets the pointer to point to an empty string.&nbsp; If the pointer
passed to writeline is null, the operation writes a blank line to the output
file.</blockquote>

<hr WIDTH="100%">
<p>From: Peter J. Ashenden &lt;petera@cs.adelaide.edu.au>
<p>In Figure 10-14 on pages 265-266, make the following changes:
<blockquote>Delete the initial value expressions in the variable declarations
for bv_s1 and bv_s2:
<blockquote><tt>variable bv_s1 : bit_vector(s1'range);</tt>
<br><tt>variable bv_s2 : bit_vector(s2'range);</tt></blockquote>
Insert the following statements immediately before the line "<tt><b>case</b>
func <b>is</b></tt>":
<blockquote><tt>bv_s1 := To_bitvector(s1);</tt>
<br><tt>bv_s2 := To_bitvector(s2);</tt></blockquote>
Change the line:
<blockquote><tt>temp_result := X"0000_0000";</tt></blockquote>
to:
<blockquote><tt>temp_result := (others => '0');&nbsp; temp_overflow :=
false;</tt></blockquote>
</blockquote>

<hr WIDTH="100%">
<p>From: Peter J. Ashenden &lt;petera@cs.adelaide.edu.au>
<p>In Figure 15-31 on page 393: Replace the declarations of the type memory_array
and the variable mem with:
<blockquote><tt><b>type</b> memory_array <b>is</b> <b>array</b> ( natural
<b>range</b>
&lt;> ) <b>of</b> dlx_bv_word;</tt>
<p><tt><b>variable</b> mem : memory_array(0 <b>to</b> high_address / 4)</tt>
<br><tt>&nbsp;&nbsp;&nbsp; := ( <b>others</b> => X"00000000" );</tt></blockquote>
Also, immediately before the declaration of procedure do_write, insert
the following procedure declaration:
<blockquote><tt><b>procedure</b> load <b>is</b></tt>
<p><tt>&nbsp;&nbsp;&nbsp; <b>constant</b> program : memory_array</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; := ( X"20020000",&nbsp;&nbsp;&nbsp;
--&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; addi&nbsp;
r2, r0, 0</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
X"ac020018",&nbsp;&nbsp;&nbsp; -- loop:&nbsp;&nbsp;&nbsp;&nbsp; sw&nbsp;&nbsp;&nbsp;
counter(r0), r2</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
X"20420001",&nbsp;&nbsp;&nbsp; --&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
addi&nbsp; r2, r2, 1</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
X"6441000a",&nbsp;&nbsp;&nbsp; --&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
snei&nbsp; r1, r2, 10</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
X"1420fff0",&nbsp;&nbsp;&nbsp; --&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
bnez&nbsp; r1, loop</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
X"44000000",&nbsp;&nbsp;&nbsp; --&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
trap&nbsp; 0</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
X"00000000" );&nbsp; -- counter:&nbsp; .word 0</tt>
<p><b><tt>begin</tt></b>
<br><tt>&nbsp;&nbsp;&nbsp; <b>assert</b> program'length &lt;= mem'length</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>report</b> "memory
too small for program"</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>severity</b> failure;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; mem(program'range) := program;</tt>
<br><tt><b>end</b> load;</tt></blockquote>
In Figure 15-31 on page 394: Insert the following statement immediately
before the line "-- initialize outputs":
<blockquote><tt>load;</tt></blockquote>
On page 392, Replace the last paragraph with:
<blockquote><font color="#000000">A behavioral architecture body for the
memory is shown in Figure 15-31.&nbsp; The process mem_behavior implements
the behavior.&nbsp; The constant high_address defines the range of addresses
to which the memory responds, based on the size of the memory.&nbsp; Next,
the process declares an array type memory_array and a variable mem of the
array type to represent the memory storage.&nbsp; Each element of the array
is a one-word bit vector.&nbsp; Since we are using byte addresses to access
memory, we must divide the high address bound by four to derive the index
range for the array of words.&nbsp; Since we have not yet described how
to use file operations to load data, we do not initialize the memory from
the file named by load_file_name.&nbsp; Instead, for this case study, we
simply use the procedure load to "preload" the memory.&nbsp; In Chapter
18, when we cover file operations, we present an alternative architecture
body that loads the memory from a file.&nbsp; The array aggregate we have
written in the declaration of the constant program in load contains the
binary representation of the small test program shown in the comments.&nbsp;
The procedure copies the program into the memory array, starting at address
0.&nbsp; The program initializes register r2 to zero and then enters a
loop.&nbsp; For each iteration, it stores the value in r2 into memory at
the location labeled "counter" and then increments r2.&nbsp; The "snei"
instruction tests whether the value in r2 is not 10, and the "bnez" instruction
transfers back to the top of the loop if the test succeeded.&nbsp; When
r2 is 10, the loop terminates, and the "trap" instruction halts execution.</font></blockquote>
On page 395, first paragraph after the figure: Replace the first sentence
with:
<blockquote>The body of the process begins by calling the load procedure
to preload the memory and initializing the memory output ports.&nbsp; It
then enters a loop to handle memory access cycles.</blockquote>

<hr WIDTH="100%">
<p>From Tom Haas &lt;tom.haas@displays.l-3com.com>
<p>In the subsection "Overloading Operator Symbols" on pages 215-217:&nbsp;
There is no mention that the syntax rule for function names is extended
beyond that shown on page 209.&nbsp; Thus the use of operator symbols as
function names appears to be inconsistent with the rules for forming identifiers,
described on page 18.
<p>To avoid this confusion, insert the following sentence on page 215 before
the last sentence ("Our bit-vector addition function..."):
<blockquote>The extended syntax rules for subprogram declarations are shown
in Appendix E.</blockquote>

<hr WIDTH="100%">
<p>From Gary M Beihl &lt;gary.m.beihl@intel.com>
<p>In Exercise 31 on page 157: A concurrent assertion statement in the
entity declaration cannot read the output port, and so cannot perform the
required verification.&nbsp; Instead, the concurrent assertion statement
must be included in the architecture body and use intermediate signals
declared in the architecture body.&nbsp; The problem statement should be
amended by replacing "Augment the entity declaration by including" with
"Include".
<p>
<hr WIDTH="100%">
<p>From Duane Clark &lt;Duane.Clark@jpl.nasa.gov>
<p>In Exercise 7 on page 52, the expression B"100010" <b>sra</b> 2 &amp;
X"2C" is syntactically correct, but semantically incorrect.&nbsp; The operator
"&amp;" has higher precedence than "sra", but has the wrong type of operands.&nbsp;
The expression should be replaced with:
<blockquote>(B"100010" <b>sra</b> 2) &amp; X"2C"</blockquote>
Then, in the answer for this expression on page 656, the expression should
be corrected in the same way and the result should be B"11100000101100".
<p>
<hr WIDTH="100%">
<p>From Peter Ashenden &lt;petera@cs.adelaide.edu.au>
<p>In Figure 20-3 on page 566, the attribute S'last_active is described
as returning time'high if no event has yet occurred.&nbsp; Replace "no
event" with "no transaction".
<p>
<hr WIDTH="100%">
<p>From Gary M Beihl &lt;gary.m.beihl@intel.com>
<p>In Figure 20-3 on page 566, the attributes S'last_event and S'last_active
are described as returning time'high if no event/transaction has yet occurred.&nbsp;
For VHDL-87, however, these attributes return 0 ns in that case.&nbsp;
Add the following sentence to the VHDL-87 paragraph below Figure 20-3:
<blockquote>Furthermore, the behavior of the 'last_event and 'last_active
attributes differs from VHDL-93.&nbsp; In VHDL-87,&nbsp; 'last_event returns
0 ns if no event has yet occurred, and 'last_active returns 0 ns if no
transaction has yet occurred.</blockquote>

<hr WIDTH="100%">
<p>From Peter Ashenden &lt;petera@cs.adelaide.edu.au>
<p>In Figure 15-35 on page 400, the labels "a" and "d" at the bottom of
the diagram should be swapped.
<p>
<hr WIDTH="100%">
<br>&nbsp;
<br>&nbsp;
</body>
</html>
