<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=windows-1252">
<META NAME="Generator" CONTENT="Microsoft Word 97">
<TITLE>TestIII_F99</TITLE>
<META NAME="Template" CONTENT="C:\Program Files\Microsoft Office\Office\html.dot">
</HEAD>
<BODY LINK="#0000ff" VLINK="#800080">

<B><FONT SIZE=5><P ALIGN="CENTER">CmpE213 – Quiz III</P>
</B></FONT><FONT SIZE=4><P ALIGN="RIGHT">Name</FONT><B>_________________________</P>
</B><U><FONT SIZE=2><P>Show all your work in the space provided.</U> Answers with a simple "yes", "no", or a single number are typically incomplete and will not be given full credit. Answers in non-reduced form, like (a+sqrt(b))/c, are fine where appropriate.</P>
<OL>

</FONT><LI>(10 Points) What is the difference between a counter mode and a timer mode (i.e. what is done differently inside the processor)?</LI>
<P>&nbsp;</P>
<LI>(10 Points) Explain why it is important to limit the scope of variables, especially when using modular programming techniques.</LI>
<LI> (13 Points) The following interrupts all occur at the same time and have the priority level shown. On the timing diagram below, show the order of execution, clearly labeling each ISR. Be sure to show when an ISR (or main) is called for a very short time (even just one instruction cycle). Assume all interrupts take several instruction cycles to complete.</LI>
<TABLE CELLSPACING=0 BORDER=0 CELLPADDING=9 WIDTH=225>
<TR><TD WIDTH="63%" VALIGN="TOP">
<P><U>Interrupt</U></TD>
<TD WIDTH="37%" VALIGN="TOP">
<U><P ALIGN="CENTER">Priority</U></TD>
</TR>
<TR><TD WIDTH="63%" VALIGN="TOP">
<P>External int. 0</TD>
<TD WIDTH="37%" VALIGN="TOP">
<P ALIGN="CENTER">0</TD>
</TR>
<TR><TD WIDTH="63%" VALIGN="TOP">
<P>Timer 1</TD>
<TD WIDTH="37%" VALIGN="TOP">
<P ALIGN="CENTER">0</TD>
</TR>
<TR><TD WIDTH="63%" VALIGN="TOP">
<P>Timer 0</TD>
<TD WIDTH="37%" VALIGN="TOP">
<P ALIGN="CENTER">1</TD>
</TR>
</TABLE>

<P>&nbsp;</P>
<LI>(16 Points) Write a short C-program which writes 1 byte of data to the serial port.</LI></OL>


<UL>
<LI>send 8 bits of data and a 9<SUP>th</SUP> "parity" bit (HINT: The 8051 automatically calculates the parity of the byte in the accumulator and stores it in PSW) </LI>
<LI>send data at 19,200 baud (assuming a 11.059MHz clock) -- show your calculations. </LI>
<LI>send a single byte, 0x79.</LI></UL>

<P>&nbsp;</P>
<OL>

<LI>(13 Points) For the above problem, show the signal that would result on TxD. Please <U>calculate </U>the time-interval, T, over which each bit is sent and show this on your plot. (HINT: The parity bit in PSW calculates even parity, in the sense that if there are an odd number of ones in the ACC, the parity bit will be one, making the total number of ones an even number.)</LI>
<P><HR ALIGN="LEFT" WIDTH="6%" SIZE=0></P>
<FONT SIZE=4><P>TxD</P>
<P>&nbsp;</P>
</FONT><LI>(16 Points) Shown below is test code and a C-language function blah(). The code was written to find naming and parameter passing methods used by a C-compiler (NOT Keil). Using this information, write the ASM equivalent for the function blah(). Please declare and use variables w, x, and y in your ASM code (variables local to blah()).</LI>
<TABLE BORDER CELLSPACING=1 CELLPADDING=9 WIDTH=721>
<TR><TD WIDTH="49%" VALIGN="TOP"><DIR>
<DIR>
<DIR>

<P><U>C-Test Code:</P>
</U><P>char blab(char x, char y){</P>
<P>&#9;return 0x13;</P>
<P>}</P>
<P>main() large{</P>
<P>&#9;char z;</P>
<P>&#9;z = blab(0x42, 0x13);</P>
<P>}</DIR>
</DIR>
</DIR>
</TD>
<TD WIDTH="51%" VALIGN="TOP">
<U><P>ASM resulting from test code:</P><DIR>
<DIR>

</U><P>; FUNCTION main (BEGIN)</P><DIR>
<DIR>

<P>MOV R5, #42H ; pass values to blah</P>
<P>MOV 25H, #13H</P>
<P>LCALL _??blab ; call function</P>
<P>MOV DPTR,#1234 ; pass return value</P>
<P>MOV A,@DPTR</P>
<P>MOV DPTR, #z ; put it in z</P>
<P>MOV @DPTR, A</P></DIR>
</DIR>

<P>; FUNCTION main (END)</DIR>
</DIR>
</TD>
</TR>
</TABLE>

<U><P>C-version of function blah:</P>
</U><P>int blah(char x, char y){</P>
<P>&#9;char w;</P>
<P>&#9;w = x + y;</P>
<P>&#9;return w</P>
<P>}</P>
<LI> (22 Points) We wish to use a timer-generated interrupt to create a PWM output. The interrupt is generated by the timer and creates a PWM waveform, according to values in two global variables, high_time and low_time.</LI></OL>


<UL>
<LI>The PWM output will be on P1^0. </LI>
<LI>The number of machine cycles the output should be high is stored in global variable "char high_time". (Hint: if we want the timer to time-out in high_time cycles, we need to load it with something slightly different than high_time). </LI>
<LI>The number of machine cycles the output should be low is stored in global variable "char low_time". </LI>
<LI>The interrupts uses timer 1 in 16-bit timer mode.</LI></UL>

<OL TYPE="a">

<LI>(11 Points) Write a short main() to initialize the timer and interrupt (and then do nothing). Start with P1^0 high and the timer running for high_time cycles.</LI>
<LI>(11 Points) Write the PWM interrupt service routine.</LI></OL>
</BODY>
</HTML>
